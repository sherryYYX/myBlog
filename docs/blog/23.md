# vue 进阶属性
## vue 指令
### vue内置指令
v-if v-for v-show v-html
### 自定义指令
组件内定义指令
```vue
new Vue({
   ...,
  directives: {
    "x": directiveOptions
  }
})
```

directiveOptions 里5个函数属性
1. bind(el , info, vnode,oldVnode) 类似created
2. inserted(参数同上) 类似mounted
3. update(参数同上) 类似 updated
4. componentUpdated(参数同上) 用的不多
5. unbind(参数同上) 类似 destroyed
### 指令的作用
1. 主要用于 DOM 操作
vue 实例/组件 用于数据绑定，事件监听、DOM更新
vue 指令主要用于对原声 `DOM` 的操作
2. 减少重复
如果某个DOM操作经常使用或者比较复杂，就封装成指令
## mixins 混入
混入就是**复制**
### 作用 
vue 指令作用是减少 `DOM` 操作的重复
mixins 的作用是减少 data、methods、钩子的重复
### 需求描述
假如我们需要在每个组件上添加name和time，一共5个组件
1. 一种方法是给每个组件添加data
2. 第二种用mixins，减少重复
::: details 例子代码 
```vue
//1.单独写个对象把data、钩子、封装起来
const log = { 
  data() {
    return {
      name: undefined,
      time: undefined
    };
  },
  created() {
    if (!this.name) {
      throw new Error("need name");
    }
    this.time = new Date();
    console.log(`${this.name}出生了`);
  },
  beforeDestroy() {
    const now = new Date();

    console.log(`${this.name}死亡了，共生存了 ${now - this.time} ms`);
  }
};

export default log;

//2.然后在需要的组件中引入，使用
<template>
  <div>Child1</div>
</template>

<script>
import log from "../mixins/log.js";
export default {
  data() {
    return {
      name: "Child1"
    };
  },
  created() {
    console.log("Child 1 的 created");
  },
  mixins: [log] //使用
};
</script>

```
:::

## provide 和 inject
提供和注入
### 作用
祖先栽树（provide），后人乘凉(inject)
:::details App.vue
```vue 
<template>
  <div :class="`app theme-${themeName}`">
    <Child1/>
    <button>x</button>
    <Child2/>
    <button>x</button>
    <Child3/>
    <button>x</button>
    <Child4/>
    <button>x</button>
    <Child5/>
    <button>x</button>
  </div>
</template>

<script>
import Child1 from "./components/Child1.vue";
import Child2 from "./components/Child2.vue";
import Child3 from "./components/Child3.vue";
import Child4 from "./components/Child4.vue";
import Child5 from "./components/Child5.vue";
export default {
  name: "App",
  provide() { 
    return {
      themeName: this.themeName,
      changeTheme: this.changeTheme, 
    };
  },
  data() {
    return {
      themeName: "blue", // 'red'
    };
  },
  methods: {
    changeTheme() {
      if (this.themeName === "blue") {
        this.themeName = "red";
      } else {
        this.themeName = "blue";
      }
    },
  components: {
    Child1,
    Child2,
    Child3,
    Child4,
    Child5
  }
};
</script>

<style>
.app {
  font-family: "Avenir", Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}
.app.theme-blue button {
  background: blue;
  color: white;
}
.app.theme-blue {
  color: darkblue;
}

.app.theme-red button {
  background: red;
  color: white;
}
.app.theme-red {
  color: darkred;
}
.app button {
  font-size: inherit;
}

</style>

```
:::


::: details  ChangeThemeButton.vue
```vue
<template>
  <div>
    <button @click="changeTheme">换肤</button>
  </div>
</template>
<script>
export default {
  inject: ["themeName", "changeTheme",] 
};
</script>

```
:::

::: details child1.vue
```vue
<template>
  <div>Child 1
    <change-theme-button/>
  </div>
</template>

<script>
import ChangeThemeButton from "./ChangeThemeButton.vue";
export default {
  components: {
    ChangeThemeButton
  }
};
</script>

```
:::
### 总结
大范围的 data 和 method 共用
不能只传 themeName 不传 changeTheme，因为 themeName 的值是被复制给 provide 的             
